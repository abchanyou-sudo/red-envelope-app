<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#dc2626" />
  <title>紅包記帳系統</title>

  <link rel="apple-touch-icon" sizes="192x192" id="apple-192" />
  <link rel="apple-touch-icon" sizes="512x512" id="apple-512" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="紅包記帳" />

  <!-- React / Babel -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Tailwind CDN -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Tesseract.js -->
  <script src="https://unpkg.com/tesseract.js@5/dist/tesseract.min.js"></script>

  <style>
    video, canvas { max-width: 100%; border-radius: 0.5rem; }
    .badge { padding:.1rem .5rem; border-radius:.5rem; font-size:.75rem; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
</head>
<body class="bg-white text-gray-800">
  <div id="root"></div>

  <script type="text/babel">
    // ---------- BasePath & Manifest ----------
    function detectBasePath(){
      const parts = location.pathname.split('/').filter(Boolean);
      return parts.length === 0 ? '/' : '/' + parts[0] + '/';
    }
    const basePath = detectBasePath();

    (function attachManifest(){
      const manifest = {
        name: "紅包記帳系統",
        short_name: "紅包記帳",
        start_url: basePath,
        scope: basePath,
        display: "standalone",
        background_color: "#ffffff",
        theme_color: "#dc2626",
        orientation: "portrait",
        icons: [
          { src: basePath + "icon-192.png", sizes: "192x192", type: "image/png", purpose: "any maskable" },
          { src: basePath + "icon-512.png", sizes: "512x512", type: "image/png", purpose: "any maskable" }
        ]
      };
      const url = URL.createObjectURL(new Blob([JSON.stringify(manifest)], {type:'application/json'}));
      const link = document.createElement('link');
      link.rel = 'manifest'; link.href = url; document.head.appendChild(link);
      document.getElementById('apple-192').setAttribute('href', basePath + 'icon-192.png');
      document.getElementById('apple-512').setAttribute('href', basePath + 'icon-512.png');
    })();

    // ---------- Storage Keys ----------
    const STORAGE_ENTRIES = 'giftbook-entries';
    const STORAGE_SEQ = 'giftbook-seq';

    const loadEntries = () => {
      try { return JSON.parse(localStorage.getItem(STORAGE_ENTRIES) || '[]'); }
      catch { return []; }
    };
    const saveEntries = (arr) => localStorage.setItem(STORAGE_ENTRIES, JSON.stringify(arr));
    const loadSeq = () => {
      const n = parseInt(localStorage.getItem(STORAGE_SEQ) || '1', 10);
      return isNaN(n) ? 1 : n;
    };
    const saveSeq = (n) => localStorage.setItem(STORAGE_SEQ, String(n));

    // ---------- Helpers ----------
    function useNetworkStatus(){
      const [online, setOnline] = React.useState(navigator.onLine);
      React.useEffect(()=>{
        const on = ()=>setOnline(true), off=()=>setOnline(false);
        window.addEventListener('online', on);
        window.addEventListener('offline', off);
        return ()=>{window.removeEventListener('online', on); window.removeEventListener('offline', off);};
      },[]);
      return online;
    }

    function useCamera() {
      const [stream, setStream] = React.useState(null);
      const [error, setError] = React.useState('');
      const videoRef = React.useRef(null);
      const canvasRef = React.useRef(null);

      const open = async () => {
        setError('');
        try {
          const s = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: { ideal: 'environment' }, width: { ideal: 1280 }, height: { ideal: 720 } },
            audio: false
          });
          setStream(s);
        } catch (e) {
          setError(e.message);
          alert('相機開啟失敗：' + e.message + '\\n提示：請在 Safari 的網站設定允許此網站的相機存取，或改用「從相簿選擇」。');
        }
      };

      const close = () => { stream?.getTracks().forEach(t => t.stop()); setStream(null); };

      React.useEffect(() => {
        if (videoRef.current && stream) {
          videoRef.current.srcObject = stream;
          videoRef.current.play().catch(()=>{});
        }
      }, [stream]);

      const snap = () => {
        const v = videoRef.current, c = canvasRef.current;
        if (!v || !c) return null;
        const w = v.videoWidth, h = v.videoHeight;
        if (!w || !h) return null;
        c.width = w; c.height = h;
        c.getContext('2d').drawImage(v, 0, 0, w, h);
        return c.toDataURL('image/png');
      };

      return { videoRef, canvasRef, open, close, snap, stream, error };
    }

    // ---------- OCR Utilities ----------
    // 合法面額集合（可擴充 2000）
    const ALLOWED = new Set([100, 200, 500, 1000]);

    // 中文大寫映射
    const CN_MAP = {
      "壹佰": 100, "貳佰": 200, "伍佰": 500, "壹仟": 1000,
      "壹百": 100, "貳百": 200, "伍百": 500, "壹千": 1000
    };

    // 從影像估計主色相（簡化取樣）
    async function estimateDominantHue(dataUrl){
      const img = new Image();
      img.crossOrigin = 'anonymous';
      const p = new Promise((resolve, reject) => {
        img.onload = () => {
          const cv = document.createElement('canvas');
          const ctx = cv.getContext('2d');
          const W = 200, H = Math.round(img.height * (200 / img.width));
          cv.width = W; cv.height = H;
          ctx.drawImage(img, 0, 0, W, H);
          const { data } = ctx.getImageData(0, 0, W, H);
          let sumH = 0, cnt = 0, reds = 0, greens = 0, blues = 0, browns = 0;
          for (let i = 0; i < data.length; i += 16) { // 跳采樣提速
            const r = data[i]/255, g = data[i+1]/255, b = data[i+2]/255;
            const max = Math.max(r,g,b), min = Math.min(r,g,b);
            const v = max, s = max === 0 ? 0 : (max-min)/max;
            if (s < 0.2 || v < 0.2) continue; // 去除灰暗
            let h = 0;
            if (max !== min) {
              const d = max - min;
              if (max === r) h = (g - b) / d + (g < b ? 6 : 0);
              else if (max === g) h = (b - r) / d + 2;
              else h = (r - g) / d + 4;
              h *= 60;
            }
            sumH += h; cnt++;
            // 色系計數（簡單分群）
            if (h <= 20 || h >= 340) reds++;
            else if (h >= 80 && h <= 160) greens++;
            else if (h >= 190 && h <= 250) blues++;
            else if (h >= 20 && h <= 50) browns++;
          }
          if (!cnt) return resolve({ hue: null, bucket: null });
          const avgH = sumH / cnt;
          let bucket = 'other';
          let maxBucket = Math.max(reds, greens, blues, browns);
          if (maxBucket === reds) bucket = 'red';
          else if (maxBucket === greens) bucket = 'green';
          else if (maxBucket === blues) bucket = 'blue';
          else if (maxBucket === browns) bucket = 'brown';
          resolve({ hue: avgH, bucket });
        };
        img.onerror = reject;
      });
      img.src = dataUrl;
      return p;
    }

    // 依主色推測面額
    function amountByColor(bucket){
      if (bucket === 'red') return 100;
      if (bucket === 'green') return 200;
      if (bucket === 'brown') return 500;
      if (bucket === 'blue') return 1000;
      return null;
    }

    // 從 OCR 文字中提取合理面額（避免撿到 71、序號等）
    async function extractAmountSmart(text, dataUrl){
      // 1) 中文大寫優先
      for (const k of Object.keys(CN_MAP)) {
        if (text.includes(k)) return CN_MAP[k];
      }

      // 2) 移除貨幣代碼與常見誤字母
      let cleaned = text.replace(/[,\s]/g, '')
                        .replace(/NTD|TWD|NT|\$|元/g, '')
                        .replace(/[Oo]/g, '0')
                        .replace(/[Il]/g, '1');

      // 3) 收集所有 3~4 位數（因你的面額集合），再篩 ALLOWED
      const matches = cleaned.match(/\d{3,4}/g) || [];
      const candidates = matches.map(n => parseInt(n, 10)).filter(n => ALLOWED.has(n));

      if (candidates.length === 1) return candidates[0];
      if (candidates.length > 1) {
        // 多個候選：選最大者（通常面額字最大/最清楚），或 1000>500>200>100 的優先序
        const order = [1000, 500, 200, 100];
        for (const v of order) if (candidates.includes(v)) return v;
      }

      // 4) 若沒有合格數字，試著用顏色主題猜測
      if (dataUrl) {
        try {
          const { bucket } = await estimateDominantHue(dataUrl);
          const guess = amountByColor(bucket);
          if (guess) return guess;
        } catch {}
      }

      // 5) 仍無：回傳 null 代表需要人工輸入
      return null;
    }

    // 文字清理：抽取姓名（2~4 連續中文字）
    function extractName(text){
      const m = text.match(/[\u4e00-\u9fff]{2,4}/);
      return m ? m[0] : '';
    }

    async function warmupOCR(){
      const w = await Tesseract.createWorker();
      await w.loadLanguage('chi_tra+eng');
      await w.initialize('chi_tra+eng');
      await w.terminate();
    }

    // ---------- App ----------
    function App(){
      const online = useNetworkStatus();
      const cam = useCamera();
      const [busy, setBusy] = React.useState(false);
      const [langReady, setLangReady] = React.useState(false);
      const [diag, setDiag] = React.useState({ sw: '未知', scope: '' });

      const [name, setName] = React.useState('');
      const [amount, setAmount] = React.useState('');
      const [code, setCode] = React.useState(loadSeq());
      const [entries, setEntries] = React.useState(loadEntries());

      React.useEffect(() => {
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.register(basePath + 'service-worker.js', { scope: basePath })
            .then(reg => setDiag({ sw: '已註冊', scope: reg.scope }))
            .catch(err => setDiag({ sw: '註冊失敗：' + err.message, scope: '' }));
        } else {
          setDiag({ sw: '不支援', scope: '' });
        }
      }, []);

      const ensureLang = async () => {
        if (langReady) return;
        if (!online) { alert('首次使用 OCR 需要網路下載語言資料，請先連線再試。'); return; }
        setBusy(true);
        try { await warmupOCR(); setLangReady(true); }
        catch (e) { alert('下載 OCR 語言資料失敗：' + e.message); }
        finally { setBusy(false); }
      };

      const runOCR = async (dataUrl) => {
        setBusy(true);
        try {
          const w = await Tesseract.createWorker();
          await w.loadLanguage('chi_tra+eng');
          await w.initialize('chi_tra+eng');
          // 嘗試兩階段：先限制數字，再通用
          await w.setParameters({ tessedit_char_whitelist: '0123456789', tessedit_pageseg_mode: '6' });
          const r1 = await w.recognize(dataUrl);
          const digitsText = r1.data.text || '';
          // 再跑通用，補姓名
          await w.setParameters({ tessedit_char_whitelist: '', tessedit_pageseg_mode: '6' });
          const r2 = await w.recognize(dataUrl);
          const fullText = (r1.data.text || '') + '\n' + (r2.data.text || '');
          await w.terminate();

          // 抽姓名
          const nn = extractName(fullText);
          if (nn) setName(nn);

          // 抽金額（安全過濾 + 顏色提示）
          const amt = await extractAmountSmart(digitsText + '\n' + fullText, dataUrl);
          if (amt != null) setAmount(String(amt));
        } catch (e) {
          alert('辨識失敗：' + e.message);
        } finally {
          setBusy(false);
        }
      };

      // 選照片：分「拍照」與「相簿」兩個入口
      const onPickFromCamera = async (ev) => {
        await ensureLang(); if (!langReady) return;
        const file = ev.target.files?.[0]; if (!file) return;
        const reader = new FileReader();
        reader.onload = async () => { await runOCR(reader.result); };
        reader.readAsDataURL(file);
        ev.target.value = "";
      };
      const onPickFromLibrary = async (ev) => {
        await ensureLang(); if (!langReady) return;
        const file = ev.target.files?.[0]; if (!file) return;
        const reader = new FileReader();
        reader.onload = async () => { await runOCR(reader.result); };
        reader.readAsDataURL(file);
        ev.target.value = "";
      };

      const onSnapAndRecognize = async () => {
        await ensureLang(); if (!langReady) return;
        const dataUrl = cam.snap();
        if (!dataUrl) { alert('相機尚未就緒，或暫無影像。'); return; }
        await runOCR(dataUrl);
      };

      const addEntry = () => {
        if (!name && !amount) { alert('請先輸入或辨識出「名字」或「金額」。'); return; }
        const now = new Date();
        const entry = { id: now.getTime(), dateISO: now.toISOString(), code, name, amount: amount?Number(amount):'' };
        const next = [entry, ...entries];
        setEntries(next); saveEntries(next);
        const nextCode = (Number(code) || 0) + 1;
        setCode(nextCode); saveSeq(nextCode);
        setName(''); setAmount('');
      };

      const resetCode = () => {
        if (confirm('確定要把「編碼」重設為 1 嗎？')) { setCode(1); saveSeq(1); }
      };

      const removeEntry = (id) => {
        const next = entries.filter(e => e.id !== id);
        setEntries(next); saveEntries(next);
      };

      const exportCSV = () => {
        const header = ['日期','編碼','名字','金額'];
        const rows = entries.map(e => [new Date(e.dateISO).toLocaleString(), e.code, e.name, e.amount]);
        const csv = [header, ...rows].map(r => r.map(x => `"${(x??'').toString().replace(/"/g,'""')}"`).join(',')).join('\n');
        const url = URL.createObjectURL(new Blob([csv], {type:'text/csv;charset=utf-8;'}));
        const a = Object.assign(document.createElement('a'), { href:url, download:'giftbook.csv' });
        document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
      };

      return (
        <div className="max-w-xl mx-auto p-4 space-y-4">
          <div className="flex items-center justify-between">
            <h1 className="text-2xl font-bold text-red-600">紅包記帳系統</h1>
            <div className="flex items-center gap-2">
              <span className={"badge " + (online ? "bg-green-100 text-green-700":"bg-gray-200 text-gray-600")}>
                {online ? "線上" : "離線"}
              </span>
              <span className="badge bg-gray-100 text-gray-700">編碼：{code}</span>
            </div>
          </div>

          <details className="p-3 border rounded-md">
            <summary className="cursor-pointer">說明 / 診斷（展開）</summary>
            <div className="text-sm text-gray-600 mt-2 space-y-1">
              <div>．**金額** 只接受 100/200/500/1000，避免抓到序號與「71」等誤判。</div>
              <div>．會結合「主色」判斷（紅=100、綠=200、咖啡=500、藍=1000）。</div>
              <div>．首次辨識需網路下載 OCR 語言檔；之後可能離線可用（視瀏覽器快取）。</div>
            </div>
          </details>

          <div className="space-y-2 p-3 border rounded-lg">
            <div className="font-semibold">相片/相機</div>
            <div className="flex gap-2 flex-wrap">
              <label className="px-3 py-2 rounded border cursor-pointer">
                拍照
                <input type="file" accept="image/*" capture="environment" className="hidden" onChange={onPickFromCamera} />
              </label>
              <label className="px-3 py-2 rounded border cursor-pointer">
                從相簿選擇
                <input type="file" accept="image/*" className="hidden" onChange={onPickFromLibrary} />
              </label>
              {!cam.stream
                ? <button onClick={cam.open} className="px-3 py-2 rounded bg-red-600 text-white">開啟相機</button>
                : <button onClick={cam.close} className="px-3 py-2 rounded border">關閉相機</button>
              }
              <button onClick={onSnapAndRecognize} className="px-3 py-2 rounded border">拍照（串流）並辨識</button>
            </div>
            <video ref={cam.videoRef} playsInline muted className="w-full bg-black/5"></video>
            <canvas ref={cam.canvasRef} className="hidden"></canvas>
            {busy && <div className="text-sm text-gray-500">載入/辨識中（首次需要網路下載 OCR 語言檔）...</div>}
          </div>

          <div className="grid grid-cols-3 gap-3">
            <div className="col-span-1">
              <label className="text-sm text-gray-600">編碼（自動）</label>
              <div className="flex items-center gap-2">
                <input className="w-full border rounded p-2 mono" value={code} onChange={e=>setCode(e.target.value)} inputMode="numeric" />
                <button onClick={resetCode} className="px-2 py-2 rounded border text-xs">重設為 1</button>
              </div>
            </div>
            <div className="col-span-1">
              <label className="text-sm text-gray-600">名字</label>
              <input className="w-full border rounded p-2" value={name} onChange={e=>setName(e.target.value)} placeholder="例如：王小明" />
            </div>
            <div className="col-span-1">
              <label className="text-sm text-gray-600">金額</label>
              <input className="w-full border rounded p-2 mono" value={amount} onChange={e=>setAmount(e.target.value)} inputMode="numeric" placeholder="100/200/500/1000" />
            </div>
            <div className="col-span-3">
              <button onClick={addEntry} className="px-4 py-2 rounded bg-red-600 text-white">新增記錄</button>
            </div>
          </div>

          <div className="flex justify-between items-center">
            <div className="font-semibold">記錄列表（儲存在本機）</div>
            <button onClick={exportCSV} className="px-3 py-2 rounded border">匯出 CSV</button>
          </div>
          <div className="space-y-2">
            {entries.length === 0 && <div className="text-sm text-gray-500">目前尚無資料</div>}
            {entries.map(e => (
              <div key={e.id} className="p-3 border rounded-md flex items-center justify-between">
                <div>
                  <div className="font-medium">#{e.code} · {e.name || '（未填名）'} · ${e.amount || '—'}</div>
                  <div className="text-xs text-gray-500">{new Date(e.dateISO).toLocaleString()}</div>
                </div>
                <button className="text-sm text-red-600" onClick={()=>removeEntry(e.id)}>刪除</button>
              </div>
            ))}
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App/>);
  </script>
</body>
</html>
